import argparse

from data_fetching import fetch_auctions, compute_split_solutions
from mechanism import (
    Solution,
    FilterRankRewardMechanism,
    NoFilter,
    BaselineFilter,
    DirectedTokenPairs,
    DirectSelection,
    MonotoneSelection,
    SubsetFilteringSelection,
    ReferenceReward,
    SingleSurplusSelection,
    AuctionMechanism,
    get_orders,
)


def run_counter_factual_analysis(
        solutions_batch: list[list[Solution]],
        mechanisms: list[AuctionMechanism],
        remove_executed_orders: bool = True
):
    """Runs a counterfactual analysis across multiple mechanisms on a given batch of solutions.

    This function assesses the total rewards for each mechanism by iterating through
    a batch of solutions, applying the winning rules and associated rewards of each
    mechanism. It allows the option to remove already executed orders from subsequent
    evaluations to avoid their repeated inclusion.

    Parameters
    ----------
    solutions_batch : list[list[Solution]]
        A batch of solutions, where each solution is a list corresponding to different
        order settings and their outcomes under evaluation.

    mechanisms : list[AuctionMechanism]
        A list of mechanisms that define the rules for determining winners and calculating
        corresponding rewards.

    remove_executed_orders : bool, optional
        If set to `True`, orders that have already been executed (settled) are removed
        from subsequent evaluations. Defaults to `True`.

    Returns
    -------
    statistics: list
        A list of total rewards, where each element corresponds to the total reward
        calculated for each mechanism in the input list of mechanisms.
    """
    statistics = []
    for mechanism in mechanisms:
        total_reward_for_mechanism = 0
        order_uids_settled: set[str] = set()
        for solutions in solutions_batch:
            # filter orders which are already settled
            if remove_executed_orders:
                solutions_filtered = [
                    remove_order_from_solution(solution, order_uids_settled) for
                    solution in solutions
                ]
            else:
                solutions_filtered = list(solutions)
            winners, rewards = mechanism.winners_and_rewards(solutions_filtered)
            total_reward_for_mechanism += sum(reward for reward, _ in rewards.values())
            order_uids_settled.update(get_orders(winners))
        statistics.append(total_reward_for_mechanism)
    return statistics


def display_statistics(statistics):
    """Displays statistical information about generated rewards.

    This function prints out the rewards generated by different mechanisms in
    terms of ETH and their relative percentage increase compared to the first
    mechanism's reward.

    Parameters
    ----------
    statistics : list of int
        A list containing the reward values generated by different mechanisms.
        Each reward value is expected to be denominated in wei (1 ETH = 10^18 wei).
    """
    print("Statistics:")
    for i, statistic in enumerate(statistics):
        print(f"mechanism {i} generated rewards of {statistic / 10 ** 18} ETH "
              f"(relative increase: {(statistic / statistics[0] - 1) * 100:.2f}%)")


def remove_order_from_solution(solution: Solution, order_uids: set[str]):
    """Removes specific orders from a given solution based on a set of order unique IDs.

    This function is designed to filter out trades from a given solution object whose
    unique IDs are specified in the provided set of order IDs. The resulting solution
    will retain all attributes from the original except for the filtered trades, and
    the score will be recalculated based on the remaining trades.

    Parameters
    ----------
    solution : Solution
        The original solution object containing all trades and associated metadata.
    order_uids : set[str]
        A set of unique IDs representing the orders to be removed from the solution.

    Returns
    -------
    Solution
        A new solution object that contains only the trades not filtered out
        based on the provided order unique IDs, with an updated score.
    """
    trades_filtered = [trade for trade in solution.trades if trade.id not in order_uids]
    solution_filtered = Solution(
        id=solution.id,
        solver=solution.solver,
        score=sum(trade.score for trade in trades_filtered),
        trades=trades_filtered,
    )
    return solution_filtered


def main():
    """Main function to run the counterfactual analysis."""
    parser = argparse.ArgumentParser(
        description="Run counterfactual analysis on auction solutions.")
    parser.add_argument("--auction_start", type=int, default=10322553 - 50000,
                        help="Start block for fetching auctions (default: 10322553 - 50000)")
    parser.add_argument("--auction_end", type=int, default=10322553,
                        help="End block for fetching auctions (default: 10322553)")
    parser.add_argument("--efficiency_loss", type=float, default=0.01,
                        help="Efficiency loss parameter (default: 0.01)")
    parser.add_argument("--approach", type=str, default="complete",
                        help="Approach type for solution splitting (default: complete)")
    parser.add_argument("--reward_upper_cap", type=int, default=12 * 10 ** 15,
                        help="Upper cap for rewards in wei (default: 12 * 10^15)")
    parser.add_argument("--reward_lower_cap", type=int, default=10 ** 16,
                        help="Lower cap for rewards in wei (default: 10^16)")

    args = parser.parse_args()

    # fetch auctions and split
    # this can take around 1 minute the first time it is run and creates a file of 80MB
    auction_start = args.auction_start
    auction_end = args.auction_end
    print(f"Fetching auctions from {auction_start} to {auction_end}...")
    solutions_batch = fetch_auctions(auction_start, auction_end)
    efficiency_loss = args.efficiency_loss
    approach = args.approach
    print(
        f"Splitting solutions with efficiency loss {efficiency_loss} "
        f"and approach \"{approach}\"..."
    )
    solutions_batch_split = [
        compute_split_solutions(solutions, efficiency_loss=efficiency_loss, approach=approach)
        for solutions in solutions_batch
    ]

    # compare 3 mechanisms
    # 1. current, single winner
    # 2. currently implemented multiple winners, with less restrictive filtering
    # 3. slightly more sophisticated selection of multiple winners
    reward_cap_upper = args.reward_upper_cap
    reward_cap_lower = args.reward_lower_cap
    print(f"Using reward caps of {reward_cap_upper / 10 ** 18} and {reward_cap_lower / 10 ** 18}")

    mechanisms = [
        # our current mechanism
        FilterRankRewardMechanism(
            NoFilter(),
            DirectSelection(SingleSurplusSelection()),
            ReferenceReward(DirectSelection(SingleSurplusSelection()), reward_cap_upper,
                            reward_cap_lower),
        ),
        # greedy choice of batches by surplus, with fairness filtering
        FilterRankRewardMechanism(
            BaselineFilter(),
            DirectSelection(
                SubsetFilteringSelection(
                    filtering_function=DirectedTokenPairs(), cumulative_filtering=False
                )
            ),
            ReferenceReward(DirectSelection(
                SubsetFilteringSelection(
                    filtering_function=DirectedTokenPairs(), cumulative_filtering=False
                )
            ), reward_cap_upper, reward_cap_lower),
        ),
        # greedy choice of batches by surplus, in iteration checking for positive rewards
        # with fairness filtering
        FilterRankRewardMechanism(
            BaselineFilter(),
            MonotoneSelection(
                SubsetFilteringSelection(
                    filtering_function=DirectedTokenPairs(), cumulative_filtering=False
                )
            ),
            ReferenceReward(DirectSelection(
                SubsetFilteringSelection(
                    filtering_function=DirectedTokenPairs(), cumulative_filtering=False
                )
            ), reward_cap_upper, reward_cap_lower),
        )
    ]

    print("Running counterfactual analysis...")
    result = run_counter_factual_analysis(solutions_batch_split, mechanisms)

    display_statistics(result)


if __name__ == "__main__":
    main()
